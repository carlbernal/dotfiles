FUNCTION  FugitiveExtractGitDir()
Called 8 times
Total time:   0.003615
 Self time:   0.002419

count  total (s)   self (s)
    8   0.000135   0.000057   let path = s:Slash(a:path)
    8              0.000062   if path =~# '^fugitive:'
                                return matchstr(path, '\C^fugitive:\%(//\)\=\zs.\{-\}\ze\%(//\|::\|$\)')
                              elseif empty(path)
                                return ''
                              elseif isdirectory(path)
    8              0.000148     let path = fnamemodify(path, ':p:s?/$??')
    8              0.000010   else
                                let path = fnamemodify(path, ':p:h:s?/$??')
                              endif
    8              0.000110   let pre = substitute(matchstr(path, '^\a\a\+\ze:'), '^.', '\u&', '')
    8              0.000030   if len(pre) && exists('*' . pre . 'Real')
                                let path = s:Slash({pre}Real(path))
                              endif
    8              0.000111   let root = resolve(path)
    8              0.000016   if root !=# path
                                silent! exe (haslocaldir() ? 'lcd' : exists(':tcd') && haslocaldir(-1) ? 'tcd' : 'cd') '.'
                              endif
    8              0.000016   let previous = ""
    8              0.000080   let env_git_dir = len($GIT_DIR) ? s:Slash(simplify(fnamemodify(FugitiveVimPath($GIT_DIR), ':p:s?[\/]$??'))) : ''
    8   0.000216   0.000073   call s:Tree(env_git_dir)
   16              0.000049   while root !=# previous
   16              0.000147     if root =~# '\v^//%([^/]+/?)?$'
                                  break
                                endif
   16   0.000633   0.000119     if index(s:CeilingDirectories(), root) >= 0
                                  break
                                endif
   16              0.000082     if root ==# $GIT_WORK_TREE && FugitiveIsGitDir(env_git_dir)
                                  return env_git_dir
                                elseif has_key(s:dir_for_worktree, root)
                                  return s:dir_for_worktree[root]
                                endif
   16              0.000208     let dir = substitute(root, '[\/]$', '', '') . '/.git'
   16              0.000123     let type = getftype(dir)
   16   0.000329   0.000074     if type ==# 'dir' && FugitiveIsGitDir(dir)
    8              0.000013       return dir
                                elseif type ==# 'link' && FugitiveIsGitDir(dir)
                                  return resolve(dir)
                                elseif type !=# '' && filereadable(dir)
                                  let line = get(readfile(dir, '', 1), 0, '')
                                  let file_dir = s:Slash(FugitiveVimPath(matchstr(line, '^gitdir: \zs.*')))
                                  if file_dir !~# '^/\|^\a:' && FugitiveIsGitDir(root . '/' . file_dir)
                                    return simplify(root . '/' . file_dir)
                                  elseif len(file_dir) && FugitiveIsGitDir(file_dir)
                                    return file_dir
                                  endif
                                elseif FugitiveIsGitDir(root)
                                  return root
                                endif
    8              0.000017     let previous = root
    8              0.000039     let root = fnamemodify(root, ':h')
    8              0.000011   endwhile
                              return ''

FUNCTION  <SNR>73_map_keys()
Called 3 times
Total time:   0.002061
 Self time:   0.002061

count  total (s)   self (s)
    3              0.000033   let bidx_mode = get(g:, 'airline#extensions#tabline#buffer_idx_mode', 1)
    3              0.000011   if bidx_mode > 0
    3              0.000009     if bidx_mode == 1
   30              0.000120       for i in range(1, 9)
   27              0.001437         exe printf('noremap <silent> <Plug>AirlineSelectTab%d :call <SID>select_tab(%d)<CR>', i, i-1)
   27              0.000054       endfor
    3              0.000006     else
                                  let start_idx = bidx_mode == 2 ? 11 : 1
                                  for i in range(start_idx, 99)
                                    exe printf('noremap <silent> <Plug>AirlineSelectTab%02d :call <SID>select_tab(%d)<CR>', i, i-start_idx)
                                  endfor
                                endif
    3              0.000130     noremap <silent> <Plug>AirlineSelectPrevTab :<C-u>call <SID>jump_to_tab(-v:count1)<CR>
    3              0.000112     noremap <silent> <Plug>AirlineSelectNextTab :<C-u>call <SID>jump_to_tab(v:count1)<CR>
                                " Enable this for debugging
                                " com! AirlineBufferList :echo map(copy(s:current_visible_buffers), {i,k -> k.": ".bufname(k)})
    3              0.000007   endif

FUNCTION  airline#parts#iminsert()
Called 8 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
    8              0.000027   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
    8              0.000009   return ''

FUNCTION  airline#check_mode()
Called 8 times
Total time:   0.074074
 Self time:   0.002275

count  total (s)   self (s)
    8              0.000050   if !has_key(s:contexts, a:winnr)
                                return ''
                              endif
    8              0.000051   let context = s:contexts[a:winnr]
                            
    8              0.000048   if get(w:, 'airline_active', 1)
    8              0.000052     let l:m = mode(1)
    8              0.000030     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m[0] ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "Rv"
                                  let l:mode =['replace']
                                elseif l:m[0] ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m[0] =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                elseif l:m ==# "t"
                                  let l:mode = ['terminal']
                                elseif l:m[0] ==# "c"
    2              0.000016       let l:mode = ['commandline']
    2              0.000007     elseif l:m ==# "no"   " does not work, most likely, Vim does not refresh the statusline in OP mode
                                  let l:mode = ['normal']
                                elseif l:m[0:1] ==# 'ni'
                                  let l:mode = ['normal']
                                  let l:m = 'ni'
                                else
    6              0.000025       let l:mode = ['normal']
    6              0.000008     endif
    8              0.000074     if exists("*VMInfos") && !empty(VMInfos())
                                  " Vim plugin Multiple Cursors https://github.com/mg979/vim-visual-multi
                                  let l:m = 'multi'
                                endif
    8              0.000093     if index(['Rv', 'no', 'ni', 'ix', 'ic', 'multi'], l:m) == -1
    8              0.000031       let l:m = l:m[0]
    8              0.000011     endif
    8              0.000072     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
    8              0.000011   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
    8              0.000053   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
    8              0.000030   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
    8              0.000149   if g:airline_detect_crypt && exists("+key") && !empty(&key)
                                call add(l:mode, 'crypt')
                              endif
                            
    8              0.000032   if g:airline_detect_spell && &spell
                                call add(l:mode, 'spell')
                              endif
                            
    8              0.000029   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
    8              0.000066   let mode_string = join(l:mode)
    8              0.000058   if get(w:, 'airline_lastmode', '') != mode_string
    4   0.002768   0.000099     call airline#highlighter#highlight_modified_inactive(context.bufnr)
    4   0.068909   0.000104     call airline#highlighter#highlight(l:mode, context.bufnr)
    4   0.000378   0.000054     call airline#util#doautocmd('AirlineModeChanged')
    4              0.000013     let w:airline_lastmode = mode_string
    4              0.000003   endif
                            
    8              0.000011   return ''

FUNCTION  airline#util#append()
Called 56 times
Total time:   0.000756
 Self time:   0.000756

count  total (s)   self (s)
   56              0.000171   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
   56              0.000234   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
   56              0.000208   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  airline#themes#get_highlight()
Called 80 times
Total time:   0.010834
 Self time:   0.000649

count  total (s)   self (s)
   80   0.010804   0.000619   return call('airline#highlighter#get_highlight', [a:group] + a:000)

FUNCTION  FugitiveWorkTree()
Called 8 times
Total time:   0.000579
 Self time:   0.000078

count  total (s)   self (s)
    8   0.000576   0.000075   return s:Tree(FugitiveGitDir(a:0 ? a:1 : -1))

FUNCTION  <SNR>97_Tree()
Called 8 times
Total time:   0.000641
 Self time:   0.000062

count  total (s)   self (s)
    8   0.000637   0.000058   return a:0 ? FugitiveWorkTree(a:1) : FugitiveWorkTree()

FUNCTION  airline#extensions#tabline#buffers#get()
Called 3 times
Total time:   0.002303
 Self time:   0.000242

count  total (s)   self (s)
    3              0.000012   try
    3   0.002124   0.000063     call <sid>map_keys()
    3              0.000009   catch
                                " no-op
                              endtry
    3              0.000031   let cur = bufnr('%')
    3              0.000035   if cur == s:current_bufnr && &columns == s:column_width
    3              0.000048     if !g:airline_detect_modified || getbufvar(cur, '&modified') == s:current_modified
    3              0.000017       return s:current_tabline
                                endif
                              endif
                            
                              let b = airline#extensions#tabline#new_builder()
                              let tab_bufs = tabpagebuflist(tabpagenr())
                              let show_buf_label_first = 0
                            
                              if get(g:, 'airline#extensions#tabline#buf_label_first', 0)
                                let show_buf_label_first = 1
                              endif
                              if show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 0)
                              endif
                            
                              let b.tab_bufs = tabpagebuflist(tabpagenr())
                            
                              let b.overflow_group = 'airline_tabhid'
                              let b.buffers = airline#extensions#tabline#buflist#list()
                              if get(g:, 'airline#extensions#tabline#current_first', 0)
                                if index(b.buffers, cur) > -1
                                  call remove(b.buffers, index(b.buffers, cur))
                                endif
                                let b.buffers = [cur] + b.buffers
                              endif
                            
                              function! b.get_group(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                if bufnum == -1
                                  return ''
                                endif
                                let group = airline#extensions#tabline#group_of_bufnr(self.tab_bufs, bufnum)
                                if bufnum == bufnr('%')
                                  let s:current_modified = (group == 'airline_tabmod') ? 1 : 0
                                endif
                                return group
                              endfunction
                            
                              if has("tablineat")
                                function! b.get_pretitle(i) dict
                                  let bufnum = get(self.buffers, a:i, -1)
                                  return '%'.bufnum.'@airline#extensions#tabline#buffers#clickbuf@'
                                endfunction
                            
                                function! b.get_posttitle(i) dict
                                  return '%X'
                                endfunction
                              endif
                            
                              function! b.get_title(i) dict
                                let bufnum = get(self.buffers, a:i, -1)
                                let group = self.get_group(a:i)
                                let pgroup = self.get_group(a:i - 1)
                                " always add a space when powerline_fonts are used
                                " or for the very first item
                                if get(g:, 'airline_powerline_fonts', 0) || a:i == 0
                                  let space = s:spc
                                else
                                  let space= (pgroup == group ? s:spc : '')
                                endif
                            
                                if get(g:, 'airline#extensions#tabline#buffer_idx_mode', 0)
                                  if len(s:number_map) > 0
                                    return space. s:get_number(a:i) . '%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)' . s:spc
                                  else
                                    return '['.(a:i+1).s:spc.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.']'
                                  endif
                                else
                                  return space.'%(%{airline#extensions#tabline#get_buffer_name('.bufnum.')}%)'.s:spc
                                endif
                              endfunction
                            
                              let current_buffer = max([index(b.buffers, cur), 0])
                              let last_buffer = len(b.buffers) - 1
                              call b.insert_titles(current_buffer, 0, last_buffer)
                            
                              call b.add_section('airline_tabfill', '')
                              call b.split()
                              call b.add_section('airline_tabfill', '')
                              if !show_buf_label_first
                                call airline#extensions#tabline#add_label(b, 'buffers', 1)
                              endif
                            
                              call airline#extensions#tabline#add_tab_label(b)
                            
                              let s:current_bufnr = cur
                              let s:column_width = &columns
                              let s:current_tabline = b.build()
                              let s:current_visible_buffers = copy(b.buffers)
                              " Do not remove from s:current_visible_buffers, this breaks s:select_tab()
                              "if b._right_title <= last_buffer
                              "  call remove(s:current_visible_buffers, b._right_title, last_buffer)
                              "endif
                              "if b._left_title > 0
                              "  call remove(s:current_visible_buffers, 0, b._left_title)
                              "endif
                              return s:current_tabline

FUNCTION  airline#util#has_fugitive()
Called 16 times
Total time:   0.000140
 Self time:   0.000140

count  total (s)   self (s)
   16              0.000048   if !exists("s:has_fugitive")
                                let s:has_fugitive = exists('*fugitive#head') || exists('*FugitiveHead')
                              endif
   16              0.000025   return s:has_fugitive

FUNCTION  airline#parts#filetype()
Called 8 times
Total time:   0.000152
 Self time:   0.000065

count  total (s)   self (s)
    8   0.000148   0.000062   return (airline#util#winwidth() < 90 && strlen(&filetype) > 3) ? matchstr(&filetype, '...'). (&encoding is? 'utf-8' ? 'â€¦' : '>') : &filetype

FUNCTION  <SNR>97_Slash()
Called 24 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
   24              0.000075   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
   24              0.000037     return a:path
                              endif

FUNCTION  airline#extensions#tabline#formatters#unique_tail#format()
Called 3 times
Total time:   0.000927
 Self time:   0.000744

count  total (s)   self (s)
    3              0.000018   let duplicates = {}
    3              0.000012   let tails = {}
    3              0.000010   let map = {}
    6              0.000029   for nr in a:buffers
    3              0.000022     let name = bufname(nr)
    3              0.000019     if empty(name)
    3   0.000271   0.000088       let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, '[No Name]')
    3              0.000006     else
                                  if name =~ 'term://'
                                    " Neovim Terminal
                                    let tail = substitute(name, '\(term:\)//.*:\(.*\)', '\1 \2', '')
                                  else
                                    let tail = fnamemodify(name, ':s?/\+$??:t')
                                  endif
                                  if has_key(tails, tail)
                                    let duplicates[nr] = nr
                                  endif
                                  let tails[tail] = 1
                                  let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, tail)
                                endif
    3              0.000009   endfor
                            
    3              0.000029   let fmod = get(g:, 'airline#extensions#tabline#fnamemod', ':p:.')
    3              0.000027   for nr in values(duplicates)
                                let name = bufname(nr)
                                let fnamecollapse = get(g:, 'airline#extensions#tabline#fnamecollapse', 1)
                                if fnamecollapse
                                  let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, substitute(fnamemodify(name, fmod), '\v\w\zs.{-}\ze(\\|/)', '', 'g'))
                                else
                                  let map[nr] = airline#extensions#tabline#formatters#default#wrap_name(nr, fnamemodify(name, fmod))
                                endif
                              endfor
                            
    3              0.000024   if has_key(map, a:bufnr)
    3              0.000018     return map[a:bufnr]
                              endif
                            
                              " if we get here, the buffer list isn't in sync with the selected buffer yet, fall back to the default
                              return airline#extensions#tabline#formatters#default#format(a:bufnr, a:buffers)

FUNCTION  airline#extensions#tabline#buflist#list()
Called 3 times
Total time:   0.000045
 Self time:   0.000045

count  total (s)   self (s)
    3              0.000027   if exists('s:current_buffer_list')
    3              0.000012     return s:current_buffer_list
                              endif
                            
                              let exclude_buffers = get(g:, 'airline#extensions#tabline#exclude_buffers', [])
                              let exclude_paths = get(g:, 'airline#extensions#tabline#excludes', [])
                              let exclude_preview = get(g:, 'airline#extensions#tabline#exclude_preview', 1)
                            
                              let list = (exists('g:did_bufmru') && g:did_bufmru) ? BufMRUList() : range(1, bufnr("$"))
                            
                              let buffers = []
                              " If this is too slow, we can switch to a different algorithm.
                              " Basically branch 535 already does it, but since it relies on
                              " BufAdd autocommand, I'd like to avoid this if possible.
                              for nr in list
                                if buflisted(nr)
                                  " Do not add to the bufferlist, if either
                                  " 1) bufnr is exclude_buffers list
                                  " 2) buffername matches one of exclude_paths patterns
                                  " 3) buffer is a quickfix buffer
                                  " 4) when excluding preview windows:
                                  "     'bufhidden' == wipe
                                  "     'buftype' == nofile
                                  " 5) ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                            
                                  " check buffer numbers first
                                  if index(exclude_buffers, nr) >= 0
                                    continue
                                  " check paths second
                                  elseif !empty(exclude_paths) && s:ExcludePaths(nr, exclude_paths)
                                    continue
                                  " ignore buffers matching airline#extensions#tabline#ignore_bufadd_pat
                                  elseif airline#util#ignore_buf(bufname(nr))
                                    continue
                                  " check other types last
                                  elseif s:ExcludeOther(nr, exclude_preview)
                                    continue
                                  endif
                            
                                  call add(buffers, nr)
                                endif
                              endfor
                            
                              let s:current_buffer_list = buffers
                              return buffers

FUNCTION  airline#mode_changed()
Called 4 times
Total time:   0.000108
 Self time:   0.000078

count  total (s)   self (s)
                              " airline#visual_active
                              " Boolean: for when to get visual wordcount
                              " needed for the wordcount extension
    4              0.000044   let g:airline#visual_active = (mode() =~? '[vs]')
    4   0.000055   0.000025   call airline#update_tabline()

FUNCTION  airline#extensions#ale#get_error()
Called 8 times
Total time:   0.001120
 Self time:   0.000055

count  total (s)   self (s)
    8   0.001116   0.000052   return airline#extensions#ale#get('error')

FUNCTION  airline#util#winwidth()
Called 48 times
Total time:   0.000551
 Self time:   0.000551

count  total (s)   self (s)
   48              0.000174   let nr = get(a:000, 0, 0)
   48              0.000124   if get(g:, 'airline_statusline_ontop', 0)
                                return &columns
                              else
   48              0.000118     return winwidth(nr)
                              endif

FUNCTION  <SNR>99_GetCounts()
Called 16 times
Total time:   0.000399
 Self time:   0.000149

count  total (s)   self (s)
   16   0.000190   0.000076     if !s:BufferCacheExists(a:buffer)
   16   0.000199   0.000063         return s:CreateCountDict()
                                endif
                            
                                call s:UpdateCacheIfNecessary(a:buffer)
                            
                                return g:ale_buffer_info[a:buffer].count

FUNCTION  airline#util#doautocmd()
Called 4 times
Total time:   0.000324
 Self time:   0.000088

count  total (s)   self (s)
    4   0.000323   0.000086   exe printf("silent doautocmd %s User %s", s:nomodeline, a:event)

FUNCTION  FugitiveIsGitDir()
Called 16 times
Total time:   0.000460
 Self time:   0.000460

count  total (s)   self (s)
   16              0.000188   let path = substitute(a:path, '[\/]$', '', '') . '/'
   16              0.000257   return len(a:path) && getfsize(path.'HEAD') > 10 && ( isdirectory(path.'objects') && isdirectory(path.'refs') || getftype(path.'commondir') ==# 'file')

FUNCTION  airline#extensions#tabline#get_buffer_name()
Called 3 times
Total time:   0.001176
 Self time:   0.000203

count  total (s)   self (s)
    3   0.000116   0.000071   let buffers = a:0 ? a:1 : airline#extensions#tabline#buflist#list()
    3              0.000031   let formatter = get(g:, 'airline#extensions#tabline#formatter', 'default')
    3   0.001022   0.000094   return airline#extensions#tabline#formatters#{formatter}#format(a:nr, buffers)

FUNCTION  <SNR>34_Slash()
Called 16 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
   16              0.000053   if exists('+shellslash')
                                return tr(a:path, '\', '/')
                              else
   16              0.000025     return a:path
                              endif

FUNCTION  <SNR>64_GetHiCmd()
Called 36 times
Total time:   0.004492
 Self time:   0.004492

count  total (s)   self (s)
                              " a:list needs to have 5 items!
   36              0.000061   let res = ''
   36              0.000060   let i = -1
  216              0.000245   while i < 4
  180              0.000273     let i += 1
  180              0.000518     let item = get(a:list, i, '')
  180              0.000238     if item is ''
   52              0.000067       continue
                                endif
  128              0.000136     if i == 0
   36              0.000119       let res .= ' guifg='.item
   36              0.000041     elseif i == 1
   36              0.000092       let res .= ' guibg='.item
   36              0.000033     elseif i == 2
   24              0.000071       let res .= ' ctermfg='.item
   24              0.000021     elseif i == 3
   24              0.000061       let res .= ' ctermbg='.item
   24              0.000021     elseif i == 4
    8              0.000042       let res .= printf(' gui=%s cterm=%s term=%s', item, item, item)
    8              0.000006     endif
  128              0.000113   endwhile
   36              0.000052   return res

FUNCTION  <SNR>65_update_untracked()
Called 8 times
Total time:   0.000161
 Self time:   0.000161

count  total (s)   self (s)
    8              0.000111   let file = expand("%:p")
    8              0.000033   if empty(file) || isdirectory(file) || !empty(&buftype)
    8              0.000009     return
                              endif
                            
                              let needs_update = 1
                              let vcs_checks   = get(g:, "airline#extensions#branch#vcs_checks", ["untracked", "dirty"])
                              for vcs in keys(s:vcs_config)
                                if file =~ s:vcs_config[vcs].exclude
                                  " Skip check for files that live in the exclude directory
                                  let needs_update = 0
                                endif
                                if has_key(s:vcs_config[vcs].untracked, file)
                                  let needs_update = 0
                                  call airline#extensions#branch#update_untracked_config(file, vcs)
                                endif
                              endfor
                            
                              if !needs_update
                                return
                              endif
                            
                              for vcs in keys(s:vcs_config)
                                " only check, for git, if fugitive is installed
                                " and for 'hg' if lawrencium is installed, else skip
                                if vcs is# 'git' && (!airline#util#has_fugitive() && !airline#util#has_gina())
                                  continue
                                elseif vcs is# 'mercurial' && !airline#util#has_lawrencium()
                                  continue
                                endif
                                let config = s:vcs_config[vcs]
                                " Note that asynchronous update updates s:vcs_config only, and only
                                " s:update_untracked updates b:buffer_vcs_config. If s:vcs_config is
                                " invalidated again before s:update_untracked is called, then we lose the
                                " result of the previous call, i.e. the head string is not updated. It
                                " doesn't happen often in practice, so we let it be.
                                if index(vcs_checks, 'untracked') > -1
                                  call airline#async#vcs_untracked(config, file, vcs)
                                endif
                                " Check clean state of repo
                                if index(vcs_checks, 'dirty') > -1
                                  call airline#async#vcs_clean(config.dirty, file, vcs)
                                endif
                              endfor

FUNCTION  <SNR>67_airline_ale_get_line_number()
Called 16 times
Total time:   0.000236
 Self time:   0.000167

count  total (s)   self (s)
                              " Use the new ALE statusline API function if it is available.
   16              0.000058   if exists("*ale#statusline#FirstProblem")
   16   0.000161   0.000092     return s:new_airline_ale_get_line_number(a:cnt, a:type)
                              endif
                            
                              return s:legacy_airline_ale_get_line_number(a:cnt, a:type)

FUNCTION  <SNR>64_group_not_done()
Called 108 times
Total time:   0.001137
 Self time:   0.001137

count  total (s)   self (s)
  108              0.000474   if index(a:list, a:name) == -1
  108              0.000412     call add(a:list, a:name)
  108              0.000149     return 1
                              else
                                if &vbs
                                  echomsg printf("airline: group: %s already done, skipping", a:name)
                                endif
                                return 0
                              endif

FUNCTION  ale#statusline#Count()
Called 16 times
Total time:   0.000548
 Self time:   0.000149

count  total (s)   self (s)
                                " The Dictionary is copied here before exposing it to other plugins.
   16   0.000534   0.000135     return copy(s:GetCounts(a:buffer))

FUNCTION  FugitiveVimPath()
Called 8 times
Total time:   0.000061
 Self time:   0.000061

count  total (s)   self (s)
    8              0.000023   if exists('+shellslash') && !&shellslash
                                return tr(a:path, '/', '\')
                              else
    8              0.000011     return a:path
                              endif

FUNCTION  ale#engine#IsCheckingBuffer()
Called 16 times
Total time:   0.000204
 Self time:   0.000204

count  total (s)   self (s)
   16              0.000073     let l:info = get(g:ale_buffer_info, a:buffer, {})
                            
   16              0.000112     return !empty(get(l:info, 'active_linter_list', []))   || !empty(get(l:info, 'active_other_sources_list', []))

FUNCTION  airline#update_tabline()
Called 4 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    4              0.000015   if get(g:, 'airline_statusline_ontop', 0)
                                call airline#extensions#tabline#redraw()
                              endif

FUNCTION  airline#extensions#fugitiveline#bufname()
Called 8 times
Total time:   0.000457
 Self time:   0.000417

count  total (s)   self (s)
    8              0.000028   if !exists('b:fugitive_name')
                                let b:fugitive_name = ''
                                try
                                  if bufname('%') =~? '^fugitive:' && exists('*FugitiveReal')
                                    let b:fugitive_name = FugitiveReal(bufname('%'))
                                  elseif exists('b:git_dir') && exists('*fugitive#repo')
                                    if get(b:, 'fugitive_type', '') is# 'blob'
                                      let b:fugitive_name = fugitive#repo().translate(FugitivePath(@%, ''))
                                    endif
                                  elseif exists('b:git_dir') && !exists('*fugitive#repo')
                                    let buffer = fugitive#buffer()
                                    if buffer.type('blob')
                                      let b:fugitive_name = buffer.repo().translate(buffer.path('/'))
                                    endif
                                  endif
                                catch
                                endtry
                              endif
                            
    8   0.000095   0.000055   let fmod = s:ModifierFlags()
    8              0.000018   if empty(b:fugitive_name)
    8              0.000067     return fnamemodify(bufname('%'), fmod)
                              else
                                return fnamemodify(b:fugitive_name, fmod). " [git]"
                              endif

FUNCTION  airline#util#wrap()
Called 64 times
Total time:   0.000504
 Self time:   0.000427

count  total (s)   self (s)
   64   0.000282   0.000205   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
   64              0.000082   return a:text

FUNCTION  airline#extensions#ale#get()
Called 16 times
Total time:   0.002244
 Self time:   0.001212

count  total (s)   self (s)
   16              0.000059   if !exists(':ALELint')
                                return ''
                              endif
                            
   16              0.000071   let error_symbol = get(g:, 'airline#extensions#ale#error_symbol', 'E:')
   16              0.000060   let warning_symbol = get(g:, 'airline#extensions#ale#warning_symbol', 'W:')
   16              0.000063   let checking_symbol = get(g:, 'airline#extensions#ale#checking_symbol', '...')
   16              0.000060   let show_line_numbers = get(g:, 'airline#extensions#ale#show_line_numbers', 1)
                            
   16              0.000043   let is_err = a:type ==# 'error'
                            
   16   0.000302   0.000098   if ale#engine#IsCheckingBuffer(bufnr('')) == 1
                                return is_err ? '' : checking_symbol
                              endif
                            
   16              0.000052   let symbol = is_err ? error_symbol : warning_symbol
                            
   16   0.000637   0.000089   let counts = ale#statusline#Count(bufnr(''))
   16              0.000076   if type(counts) == type({}) && has_key(counts, 'error')
                                " Use the current Dictionary format.
   16              0.000049     let errors = counts.error + counts.style_error
   16              0.000052     let num = is_err ? errors : counts.total - errors
   16              0.000014   else
                                " Use the old List format.
                                let num = is_err ? counts[0] : counts[1]
                              endif
                            
   16              0.000029   if show_line_numbers == 1
   16   0.000461   0.000181     return s:airline_ale_count(num, symbol) . <sid>airline_ale_get_line_number(num, a:type)
                              else
                                return s:airline_ale_count(num, symbol)
                              endif

FUNCTION  FugitiveGitDir()
Called 16 times
Total time:   0.004262
 Self time:   0.000586

count  total (s)   self (s)
   16              0.000079   if !a:0 || type(a:1) == type(0) && a:1 < 0
    8              0.000025     if exists('g:fugitive_event')
                                  return g:fugitive_event
                                endif
    8              0.000032     let dir = get(b:, 'git_dir', '')
    8              0.000042     if empty(dir) && (empty(bufname('')) || &buftype =~# '^\%(nofile\|acwrite\|quickfix\|prompt\)$')
    8   0.003708   0.000093       return FugitiveExtractGitDir(getcwd())
                                endif
                                return dir
                              elseif type(a:1) == type(0)
                                return getbufvar(a:1, 'git_dir')
                              elseif type(a:1) == type('')
    8   0.000146   0.000085     return substitute(s:Slash(a:1), '/$', '', '')
                              else
                                return ''
                              endif

FUNCTION  gutentags#statusline()
Called 8 times
Total time:   0.000132
 Self time:   0.000080

count  total (s)   self (s)
    8   0.000098   0.000046     let l:modules_in_progress = gutentags#inprogress()
    8              0.000018     if empty(l:modules_in_progress)
    8              0.000008        return ''
                                endif
                            
                                let l:prefix = ''
                                let l:suffix = ''
                                if a:0 > 0
                                   let l:prefix = a:1
                                endif
                                if a:0 > 1
                                   let l:suffix = a:2
                                endif
                            
                                if a:0 > 2
                                   let l:genmsg = a:3
                                else
                                   let l:genmsg = join(l:modules_in_progress, ',')
                                endif
                            
                                return l:prefix.l:genmsg.l:suffix

FUNCTION  airline#extensions#tabline#get()
Called 3 times
Total time:   0.002807
 Self time:   0.000504

count  total (s)   self (s)
    3              0.000085   let show_buffers = get(g:, 'airline#extensions#tabline#show_buffers', 1)
    3              0.000026   let show_tabs = get(g:, 'airline#extensions#tabline#show_tabs', 1)
                            
    3              0.000023   let curtabcnt = tabpagenr('$')
    3              0.000025   if curtabcnt != s:current_tabcnt
                                let s:current_tabcnt = curtabcnt
                                call airline#extensions#tabline#tabs#invalidate()
                                call airline#extensions#tabline#buffers#invalidate()
                                call airline#extensions#tabline#ctrlspace#invalidate()
                                call airline#extensions#tabline#tabws#invalidate()
                              endif
                            
    3              0.000033   if !exists('#airline#BufAdd#*')
                                autocmd airline BufAdd * call <sid>update_tabline(0)
                              endif
    3              0.000023   if !exists('#airline#SessionLoadPost')
                                autocmd airline SessionLoadPost * call <sid>update_tabline(1)
                              endif
    3              0.000009   if s:ctrlspace
                                return airline#extensions#tabline#ctrlspace#get()
                              elseif s:tabws
                                return airline#extensions#tabline#tabws#get()
                              elseif show_buffers && curtabcnt == 1 || !show_tabs
    3   0.002380   0.000077     return airline#extensions#tabline#buffers#get()
                              else
                                return airline#extensions#tabline#tabs#get()
                              endif

FUNCTION  airline#extensions#whitespace#check()
Called 8 times
Total time:   0.001376
 Self time:   0.001099

count  total (s)   self (s)
    8              0.000036   let max_lines = get(g:, 'airline#extensions#whitespace#max_lines', 20000)
    8              0.000057   if &readonly || !&modifiable || !s:enabled || line('$') > max_lines || get(b:, 'airline_whitespace_disabled', 0)
                                return ''
                              endif
    8              0.000070   let skip_check_ft = extend(s:skip_check_ft, get(g:, 'airline#extensions#whitespace#skip_indent_check_ft', {}), 'force')
                            
    8              0.000027   if !exists('b:airline_whitespace_check')
                                let b:airline_whitespace_check = ''
                                let checks = get(b:, 'airline_whitespace_checks', get(g:, 'airline#extensions#whitespace#checks', s:default_checks))
                            
                                let trailing = 0
                                let check = 'trailing'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  try
                                    let regexp = get(g:, 'airline#extensions#whitespace#trailing_regexp', '\s$')
                                    let trailing = search(regexp, 'nw')
                                  catch
                                    call airline#util#warning(printf('Whitespace: error occurred evaluating "%s"', regexp))
                                    echomsg v:exception
                                    return ''
                                  endtry
                                endif
                            
                                let mixed = 0
                                let check = 'indent'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed = s:check_mixed_indent()
                                endif
                            
                                let mixed_file = ''
                                let check = 'mixed-indent-file'
                                if index(checks, check) > -1 && index(get(skip_check_ft, &ft, []), check) < 0
                                  let mixed_file = s:check_mixed_indent_file()
                                endif
                            
                                let long = 0
                                if index(checks, 'long') > -1 && &tw > 0
                                  let long = search('\%>'.&tw.'v.\+', 'nw')
                                endif
                            
                                let conflicts = 0
                                if index(checks, 'conflicts') > -1
                                  let conflicts = s:conflict_marker()
                                endif
                            
                                if trailing != 0 || mixed != 0 || long != 0 || !empty(mixed_file) || conflicts != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if strlen(s:symbol) > 0
                                    let space = (g:airline_symbols.space)
                                  else
                                    let space = ''
                                  endif
                            
                                  if s:show_message
                                    if trailing != 0
                                      let trailing_fmt = get(g:, 'airline#extensions#whitespace#trailing_format', '[%s]trailing')
                                      let b:airline_whitespace_check .= space.printf(trailing_fmt, trailing)
                                    endif
                                    if mixed != 0
                                      let mixed_indent_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_format', '[%s]mixed-indent')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_fmt, mixed)
                                    endif
                                    if long != 0
                                      let long_fmt = get(g:, 'airline#extensions#whitespace#long_format', '[%s]long')
                                      let b:airline_whitespace_check .= space.printf(long_fmt, long)
                                    endif
                                    if !empty(mixed_file)
                                      let mixed_indent_file_fmt = get(g:, 'airline#extensions#whitespace#mixed_indent_file_format', '[%s]mix-indent-file')
                                      let b:airline_whitespace_check .= space.printf(mixed_indent_file_fmt, mixed_file)
                                    endif
                                    if conflicts != 0
                                      let conflicts_fmt = get(g:, 'airline#extensions#whitespace#conflicts_format', '[%s]conflicts')
                                      let b:airline_whitespace_check .= space.printf(conflicts_fmt, conflicts)
                                    endif
                                  endif
                                endif
                              endif
    8   0.000325   0.000048   return airline#util#shorten(b:airline_whitespace_check, 120, 9)

FUNCTION  <SNR>65_update_hg_branch()
Called 8 times
Total time:   0.000568
 Self time:   0.000500

count  total (s)   self (s)
    8   0.000103   0.000035   if airline#util#has_lawrencium()
                                let cmd='LC_ALL=C hg qtop'
                                let stl=lawrencium#statusline()
                                let file=expand('%:p')
                                if !empty(stl) && get(b:, 'airline_do_mq_check', 1)
                                  if g:airline#init#vim_async
                                    noa call airline#async#get_mq_async(cmd, file)
                                  elseif has("nvim")
                                    noa call airline#async#nvim_get_mq_async(cmd, file)
                                  else
                                    " remove \n at the end of the command
                                    let output=system(cmd)[0:-2]
                                    noa call airline#async#mq_output(output, file)
                                  endif
                                endif
                                " do not do mq check anymore
                                let b:airline_do_mq_check = 0
                                if exists("b:mq") && !empty(b:mq)
                                  if stl is# 'default'
                                    " Shorten default a bit
                                    let stl='def'
                                  endif
                                  let stl.=' ['.b:mq.']'
                                endif
                                let s:vcs_config['mercurial'].branch = stl
                              else
    8              0.000026     let s:vcs_config['mercurial'].branch = ''
    8              0.000006   endif

FUNCTION  gutentags#inprogress()
Called 8 times
Total time:   0.000052
 Self time:   0.000052

count  total (s)   self (s)
                                " Does this buffer have gutentags enabled?
    8              0.000027     if !exists('b:gutentags_files')
    8              0.000013         return []
                                endif
                            
                                " Find any module that has a job in progress for any of this buffer's
                                " tags files.
                                let l:modules_in_progress = []
                                for [module, tags_file] in items(b:gutentags_files)
                                    let l:jobidx = gutentags#find_job_index_by_tags_file(module, tags_file)
                                    if l:jobidx >= 0
                                        call add(l:modules_in_progress, module)
                                    endif
                                endfor
                                return l:modules_in_progress

FUNCTION  airline#extensions#branch#get_head()
Called 8 times
Total time:   0.011071
 Self time:   0.000334

count  total (s)   self (s)
    8   0.010512   0.000054   let head = airline#extensions#branch#head()
    8   0.000108   0.000067   let winwidth = get(airline#parts#get('branch'), 'minwidth', 120)
    8              0.000038   let minwidth = empty(get(b:, 'airline_hunks', '')) ? 14 : 7
    8   0.000291   0.000053   let head = airline#util#shorten(head, winwidth, minwidth)
    8              0.000039   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
    8              0.000071   return empty(head) ? get(g:, 'airline#extensions#branch#empty_message', '') : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  <SNR>67_new_airline_ale_get_line_number()
Called 16 times
Total time:   0.000069
 Self time:   0.000069

count  total (s)   self (s)
                              " The FirstProblem call in ALE is a far more efficient way
                              " of obtaining line number data. If the installed ALE supports
                              " it, we should use this method of getting line data.
   16              0.000023   if a:cnt == 0
   16              0.000015     return ''
                              endif
                              let l:buffer = bufnr('')
                            
                              " Try to get the first error from ALE.
                              let l:result = ale#statusline#FirstProblem(l:buffer, a:type)
                              if empty(l:result)
                                " If there are no errors then try and check for style errors.
                                let l:result =  ale#statusline#FirstProblem(l:buffer, 'style_' . a:type)
                              endif
                            
                              if empty(l:result)
                                  return ''
                              endif
                            
                              let l:open_lnum_symbol  = get(g:, 'airline#extensions#ale#open_lnum_symbol', '(L')
                              let l:close_lnum_symbol = get(g:, 'airline#extensions#ale#close_lnum_symbol', ')')
                            
                              return open_lnum_symbol . l:result.lnum . close_lnum_symbol

FUNCTION  <SNR>34_Tree()
Called 16 times
Total time:   0.000267
 Self time:   0.000267

count  total (s)   self (s)
   16              0.000046   let dir = a:path
   16              0.000105   if dir =~# '/\.git$'
    8              0.000038     return len(dir) ==# 5 ? '/' : dir[0:-6]
                              elseif dir ==# ''
    8              0.000011     return ''
                              endif
                              if !has_key(s:worktree_for_dir, dir)
                                let s:worktree_for_dir[dir] = ''
                                let config_file = dir . '/config'
                                if filereadable(config_file)
                                  let config = readfile(config_file,'',10)
                                  call filter(config,'v:val =~# "^\\s*worktree *="')
                                  if len(config) == 1
                                    let worktree = FugitiveVimPath(matchstr(config[0], '= *\zs.*'))
                                  endif
                                elseif filereadable(dir . '/gitdir')
                                  let worktree = fnamemodify(FugitiveVimPath(readfile(dir . '/gitdir')[0]), ':h')
                                  if worktree ==# '.'
                                    unlet! worktree
                                  endif
                                endif
                                if exists('worktree')
                                  let s:worktree_for_dir[dir] = s:Slash(resolve(worktree))
                                  let s:dir_for_worktree[s:worktree_for_dir[dir]] = dir
                                endif
                              endif
                              if s:worktree_for_dir[dir] =~# '^\.'
                                return simplify(dir . '/' . s:worktree_for_dir[dir])
                              else
                                return s:worktree_for_dir[dir]
                              endif

FUNCTION  <SNR>65_update_git_branch()
Called 8 times
Total time:   0.009000
 Self time:   0.000480

count  total (s)   self (s)
    8   0.000140   0.000051   call airline#util#ignore_next_focusgain()
    8   0.000126   0.000047   if !airline#util#has_fugitive() && !airline#util#has_gina()
                                let s:vcs_config['git'].branch = ''
                                return
                              endif
    8   0.000088   0.000028   if airline#util#has_fugitive()
    8   0.008295   0.000096     let s:vcs_config['git'].branch = exists("*FugitiveHead") ? FugitiveHead(s:sha1size) : fugitive#head(s:sha1size)
    8   0.000153   0.000060     if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
                                endif
    8              0.000006   else
                                try
                                  let g:gina#component#repo#commit_length = s:sha1size
                                  let s:vcs_config['git'].branch = gina#component#repo#branch()
                                catch
                                endtry
                                if s:vcs_config['git'].branch is# 'master' && airline#util#winwidth() < 81
                                  " Shorten default a bit
                                  let s:vcs_config['git'].branch='mas'
                                endif
                              endif

FUNCTION  FugitiveHead()
Called 8 times
Total time:   0.008199
 Self time:   0.000194

count  total (s)   self (s)
    8   0.003948   0.000063   let dir = FugitiveGitDir(a:0 > 1 ? a:2 : -1)
    8              0.000019   if empty(dir)
                                return ''
                              endif
    8   0.004206   0.000086   return fugitive#Head(a:0 ? a:1 : 0, dir)

FUNCTION  airline#highlighter#highlight()
Called 4 times
Total time:   0.068806
 Self time:   0.011786

count  total (s)   self (s)
    4              0.000029   let bufnr = a:0 ? a:1 : ''
    4              0.000041   let p = g:airline#themes#{g:airline_theme}#palette
                            
                              " draw the base mode, followed by any overrides
    4              0.000085   let mapped = map(a:modes, 'v:val == a:modes[0] ? v:val : a:modes[0]."_".v:val')
    4              0.000030   let suffix = a:modes[0] == 'inactive' ? '_inactive' : ''
    4              0.000021   let airline_grouplist = []
    4              0.000042   let buffers_in_tabpage = sort(tabpagebuflist())
    4              0.000023   if exists("*uniq")
    4              0.000029     let buffers_in_tabpage = uniq(buffers_in_tabpage)
    4              0.000007   endif
                              " mapped might be something like ['normal', 'normal_modified']
                              " if a group is in both modes available, only define the second
                              " that is how this was done previously overwrite the previous definition
    8              0.000037   for mode in reverse(mapped)
    4              0.000056     if exists('g:airline#themes#{g:airline_theme}#palette[mode]')
    4              0.000038       let dict = g:airline#themes#{g:airline_theme}#palette[mode]
   80              0.000254       for kvp in items(dict)
   76              0.000210         let mode_colors = kvp[1]
   76              0.000174         let name = kvp[0]
   76              0.000307         if name is# 'airline_c' && !empty(bufnr) && suffix is# '_inactive'
                                      let name = 'airline_c'.bufnr
                                    endif
                                    " do not re-create highlighting for buffers that are no longer visible
                                    " in the current tabpage
   76              0.000699         if name =~# 'airline_c\d\+'
                                      let bnr = matchstr(name, 'airline_c\zs\d\+') + 0
                                      if bnr > 0 && index(buffers_in_tabpage, bnr) == -1
                                        continue
                                      endif
                                    elseif (name =~# '_to_') || (name[0:10] is# 'airline_tab' && !empty(suffix))
                                      " group will be redefined below at exec_separator
                                      " or is not needed for tabline with '_inactive' suffix
                                      " since active flag is 1 for builder)
   40              0.000076           continue
                                    endif
   36   0.000699   0.000301         if s:group_not_done(airline_grouplist, name.suffix)
   36   0.011671   0.000313           call airline#highlighter#exec(name.suffix, mode_colors)
   36              0.000035         endif
                            
   36              0.000122         if !has_key(p, 'accents') 
                                      " work around a broken installation
                                      " shouldn't actually happen, p should always contain accents
                                      continue
                                    endif
                            
  108              0.000303         for accent in keys(s:accents)
   72              0.000244           if !has_key(p.accents, accent)
                                        continue
                                      endif
   72              0.000347           let colors = copy(mode_colors)
   72              0.000269           if p.accents[accent][0] != ''
   36              0.000130             let colors[0] = p.accents[accent][0]
   36              0.000033           endif
   72              0.000183           if p.accents[accent][2] != ''
   36              0.000108             let colors[2] = p.accents[accent][2]
   36              0.000026           endif
   72              0.000172           if len(colors) >= 5
   72              0.000342             let colors[4] = get(p.accents[accent], 4, '')
   72              0.000067           else
                                        call add(colors, get(p.accents[accent], 4, ''))
                                      endif
   72   0.001420   0.000681           if s:group_not_done(airline_grouplist, name.suffix.'_'.accent)
   72   0.022433   0.000668             call airline#highlighter#exec(name.suffix.'_'.accent, colors)
   72              0.000073           endif
   72              0.000088         endfor
   36              0.000035       endfor
                            
    4              0.000009       if empty(s:separators)
                                    " nothing to be done
                                    continue
                                  endif
                                  " TODO: optimize this
   44              0.000099       for sep in items(s:separators)
                                    " we cannot check, that the group already exists, else the separators
                                    " might not be correctly defined. But perhaps we can skip above groups
                                    " that match the '_to_' name, because they would be redefined here...
   40   0.023215   0.000456         call <sid>exec_separator(dict, sep[1][0], sep[1][1], sep[1][2], suffix)
   40              0.000041       endfor
    4              0.000003     endif
    4              0.000003   endfor

FUNCTION  airline#parts#ffenc()
Called 8 times
Total time:   0.000257
 Self time:   0.000257

count  total (s)   self (s)
    8              0.000036   let expected = get(g:, 'airline#parts#ffenc#skip_expected_string', '')
    8              0.000022   let bomb     = &l:bomb ? '[BOM]' : ''
    8              0.000082   let ff       = strlen(&ff) ? '['.&ff.']' : ''
    8              0.000054   if expected is# &fenc.bomb.ff
                                return ''
                              else
    8              0.000042     return &fenc.bomb.ff
                              endif

FUNCTION  airline#util#ignore_buf()
Called 8 times
Total time:   0.000205
 Self time:   0.000205

count  total (s)   self (s)
    8              0.000066   let pat = '\c\v'. get(g:, 'airline#ignore_bufadd_pat', ''). get(g:, 'airline#extensions#tabline#ignore_bufadd_pat',  '!|defx|gundo|nerd_tree|startify|tagbar|term://|undotree|vimfiler')
    8              0.000132   return match(a:name, pat) > -1

FUNCTION  airline#util#ignore_next_focusgain()
Called 8 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    8              0.000045   if has('win32')
                                " Setup an ignore for platforms that trigger FocusLost on calls to
                                " system(). macvim (gui and terminal) and Linux terminal vim do not.
                                let s:focusgained_ignore_time = localtime()
                              endif

FUNCTION  airline#parts#get()
Called 8 times
Total time:   0.000041
 Self time:   0.000041

count  total (s)   self (s)
    8              0.000037   return get(s:parts, a:key, {})

FUNCTION  airline#parts#paste()
Called 8 times
Total time:   0.000037
 Self time:   0.000037

count  total (s)   self (s)
    8              0.000034   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>34_CeilingDirectories()
Called 16 times
Total time:   0.000515
 Self time:   0.000515

count  total (s)   self (s)
   16              0.000068   if !exists('s:ceiling_directories')
                                let s:ceiling_directories = []
                                let resolve = 1
                                for dir in split($GIT_CEILING_DIRECTORIES, has('win32') ? ';' : ':', 1)
                                  if empty(dir)
                                    let resolve = 0
                                  elseif resolve
                                    call add(s:ceiling_directories, resolve(dir))
                                  else
                                    call add(s:ceiling_directories, dir)
                                  endif
                                endfor
                              endif
   16              0.000087   return s:ceiling_directories + get(g:, 'ceiling_directories', [])

FUNCTION  airline#parts#readonly()
Called 8 times
Total time:   0.000365
 Self time:   0.000160

count  total (s)   self (s)
                              " only consider regular buffers (e.g. ones that represent actual files,
                              " but not special ones like e.g. NERDTree)
    8   0.000276   0.000070   if !empty(&buftype) || airline#util#ignore_buf(bufname('%'))
                                return ''
                              endif
    8              0.000023   if &readonly && !filereadable(bufname('%'))
                                return '[noperm]'
                              else
    8              0.000019     return &readonly ? g:airline_symbols.readonly : ''
                              endif

FUNCTION  fugitive#Head()
Called 8 times
Total time:   0.004120
 Self time:   0.000486

count  total (s)   self (s)
    8              0.000036   let dir = a:0 > 1 ? a:2 : s:Dir()
    8              0.000016   if empty(dir)
                                return ''
                              endif
    8   0.003694   0.000060   let file = fugitive#Find('.git/HEAD', dir)
    8              0.000056   let ftime = getftime(file)
    8              0.000013   if ftime == -1
                                return ''
                              elseif ftime != get(s:head_cache, dir, [-1])[0]
                                let s:head_cache[dir] = [ftime, readfile(file)[0]]
                              endif
    8              0.000027   let head = s:head_cache[dir][1]
    8              0.000045   if head =~# '^ref: '
    8              0.000116     return substitute(head, '\C^ref: \%(refs/\%(heads/\|remotes/\|tags/\)\=\)\=', '', '')
                              elseif head =~# '^\x\{40,\}$'
                                let len = a:0 ? a:1 : 0
                                return len < 0 ? head : len ? head[0:len-1] : ''
                              else
                                return ''
                              endif

FUNCTION  <SNR>67_airline_ale_count()
Called 16 times
Total time:   0.000044
 Self time:   0.000044

count  total (s)   self (s)
   16              0.000038   return a:cnt ? a:symbol. a:cnt : ''

FUNCTION  airline#highlighter#exec()
Called 152 times
Total time:   0.045612
 Self time:   0.011375

count  total (s)   self (s)
  152              0.000298   if pumvisible()
                                return
                              endif
  152              0.000361   let colors = a:colors
  152              0.000249   if s:is_win32term
                                let colors[2] = s:gui2cui(get(colors, 0, ''), get(colors, 2, ''))
                                let colors[3] = s:gui2cui(get(colors, 1, ''), get(colors, 3, ''))
                              endif
  152   0.024505   0.001095   let old_hi = airline#highlighter#get_highlight(a:group)
  152              0.000390   if len(colors) == 4
   40              0.000106     call add(colors, '')
   40              0.000028   endif
  152              0.000303   if g:airline_gui_mode ==# 'gui'
  152              0.000764     let new_hi = [colors[0], colors[1], '', '', colors[4]]
  152              0.000135   else
                                let new_hi = ['', '', printf("%s", colors[2]), printf("%s", colors[3]), colors[4]]
                              endif
  152   0.005549   0.000951   let colors = s:CheckDefined(colors)
  152   0.002772   0.001035   if old_hi != new_hi || !s:hl_group_exists(a:group)
   36   0.004779   0.000287     let cmd = printf('hi %s%s', a:group, s:GetHiCmd(colors))
   36              0.000332     exe cmd
   36              0.000121     if has_key(s:hl_groups, a:group)
   36              0.000117       let s:hl_groups[a:group] = colors
   36              0.000029     endif
   36              0.000026   endif

FUNCTION  <SNR>66_ModifierFlags()
Called 8 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    8              0.000035   return (exists("+autochdir") && &autochdir) ? ':p' : ':.'

FUNCTION  <SNR>64_get_array()
Called 232 times
Total time:   0.002757
 Self time:   0.002757

count  total (s)   self (s)
  232              0.001105   let opts=empty(a:opts) ? '' : join(a:opts, ',')
  232              0.001522   return g:airline_gui_mode ==# 'gui' ? [ a:fg, a:bg, '', '', opts ] : [ '', '', a:fg, a:bg, opts ]

FUNCTION  airline#parts#spell()
Called 8 times
Total time:   0.000281
 Self time:   0.000281

count  total (s)   self (s)
    8              0.000120   let spelllang = g:airline_detect_spelllang ? printf(" [%s]", toupper(substitute(&spelllang, ',', '/', 'g'))) : ''
    8              0.000024   if g:airline_detect_spell && &spell
                                let winwidth = airline#util#winwidth()
                                if winwidth >= 90
                                  return g:airline_symbols.spell . spelllang
                                elseif winwidth >= 70
                                  return g:airline_symbols.spell
                                else
                                  return split(g:airline_symbols.spell, '\zs')[0]
                                endif
                              endif
    8              0.000009   return ''

FUNCTION  <SNR>99_CreateCountDict()
Called 16 times
Total time:   0.000136
 Self time:   0.000136

count  total (s)   self (s)
                                " Keys 0 and 1 are for backwards compatibility.
                                " The count object used to be a List of [error_count, warning_count].
   16              0.000110     return {   '0': 0,   '1': 0,   'error': 0,   'warning': 0,   'info': 0,   'style_error': 0,   'style_warning': 0,   'total': 0,}

FUNCTION  airline#parts#crypt()
Called 8 times
Total time:   0.000120
 Self time:   0.000120

count  total (s)   self (s)
    8              0.000115   return g:airline_detect_crypt && exists("+key") && !empty(&key) ? g:airline_symbols.crypt : ''

FUNCTION  airline#extensions#tabline#formatters#default#wrap_name()
Called 3 times
Total time:   0.000183
 Self time:   0.000183

count  total (s)   self (s)
    3              0.000030   let _ = s:buf_nr_show ? printf(s:buf_nr_format, a:bufnr) : ''
    3              0.000082   let _ .= substitute(a:buffer_name, '\\', '/', 'g')
                            
    3              0.000029   if getbufvar(a:bufnr, '&modified') == 1
                                let _ .= s:buf_modified_symbol
                              endif
    3              0.000010   return _

FUNCTION  airline#extensions#branch#head()
Called 8 times
Total time:   0.010458
 Self time:   0.000225

count  total (s)   self (s)
    8              0.000034   if !exists('b:buffer_vcs_config')
                                call s:init_buffer()
                              endif
                            
    8   0.010120   0.000048   call s:update_branch()
    8   0.000211   0.000050   call s:update_untracked()
                            
    8              0.000035   if exists('b:airline_head') && !empty(b:airline_head)
    8              0.000012     return b:airline_head
                              endif
                            
                              let b:airline_head = ''
                              let vcs_priority = get(g:, "airline#extensions#branch#vcs_priority", ["git", "mercurial"])
                            
                              let heads = []
                              for vcs in vcs_priority
                                if !empty(b:buffer_vcs_config[vcs].branch)
                                  let heads += [vcs]
                                endif
                              endfor
                            
                              for vcs in heads
                                if !empty(b:airline_head)
                                  let b:airline_head .= ' | '
                                endif
                                if len(heads) > 1
                                  let b:airline_head .= s:vcs_config[vcs].exe .':'
                                endif
                                let b:airline_head .= s:format_name({s:vcs_config[vcs].display_branch}())
                                let additional = b:buffer_vcs_config[vcs].untracked
                                if empty(additional) && has_key(b:buffer_vcs_config[vcs], 'dirty') && b:buffer_vcs_config[vcs].dirty
                                  let additional = g:airline_symbols['dirty']
                                endif
                                let b:airline_head .= additional
                              endfor
                            
                              if empty(heads)
                                if airline#util#has_vcscommand()
                                  noa call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = s:format_name(get(b:VCSCommandBufferInfo, 0, ''))
                                  endif
                                endif
                              endif
                            
                              if empty(heads)
                                if airline#util#has_custom_scm()
                                  try
                                    let Fn = function(g:airline#extensions#branch#custom_head)
                                    let b:airline_head = Fn()
                                  endtry
                                endif
                              endif
                            
                              if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if strwidth(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = airline#util#strcharpart(b:airline_head, 0, w:displayed_head_limit - 1) . (&encoding ==? 'utf-8' ?  'â€¦' : '.')
                                endif
                              endif
                            
                              return b:airline_head

FUNCTION  <SNR>64_hl_group_exists()
Called 116 times
Total time:   0.001737
 Self time:   0.001737

count  total (s)   self (s)
  116              0.000453   if !hlexists(a:group)
                                return 0
                              elseif empty(synIDattr(hlID(a:group), 'fg'))
                                return 0
                              endif
  116              0.000132   return 1

FUNCTION  airline#parts#mode()
Called 8 times
Total time:   0.000402
 Self time:   0.000088

count  total (s)   self (s)
    8   0.000397   0.000082   return airline#util#shorten(get(w:, 'airline_current_mode', ''), 79, 1)

FUNCTION  <SNR>99_BufferCacheExists()
Called 16 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
   16              0.000086     if !exists('g:ale_buffer_info') || !has_key(g:ale_buffer_info, a:buffer)
   16              0.000018         return 0
                                endif
                            
                                return 1

FUNCTION  airline#extensions#gutentags#status()
Called 8 times
Total time:   0.000201
 Self time:   0.000068

count  total (s)   self (s)
    8   0.000174   0.000042   let msg = gutentags#statusline()
    8              0.000020   return empty(msg) ? '' :  'Gen. ' . msg

FUNCTION  fugitive#Find()
Called 8 times
Total time:   0.003634
 Self time:   0.002451

count  total (s)   self (s)
    8              0.000033   if type(a:object) == type(0)
                                let name = bufname(a:object)
                                return FugitiveVimPath(name =~# '^$\|^/\|^\a\+:' ? name : getcwd() . '/' . name)
                              elseif a:object =~# '^[~$]'
                                let prefix = matchstr(a:object, '^[~$]\i*')
                                let owner = expand(prefix)
                                return FugitiveVimPath((len(owner) ? owner : prefix) . strpart(a:object, len(prefix)))
                              elseif s:Slash(a:object) =~# '^$\|^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                return FugitiveVimPath(a:object)
                              elseif s:Slash(a:object) =~# '^\.\.\=\%(/\|$\)'
                                return FugitiveVimPath(simplify(getcwd() . '/' . a:object))
                              endif
    8              0.000035   let dir = a:0 ? a:1 : s:Dir()
    8              0.000017   if empty(dir)
                                let file = matchstr(a:object, '^\%(:\d:\|[^:]*:\)\zs.*', '', '')
                                let dir = FugitiveExtractGitDir(file)
                                if empty(dir)
                                  return fnamemodify(FugitiveVimPath(len(file) ? file : a:object), ':p')
                                endif
                              endif
    8   0.000100   0.000041   let rev = s:Slash(a:object)
    8   0.000686   0.000045   let tree = s:Tree(dir)
    8              0.000044   let base = len(tree) ? tree : 'fugitive://' . dir . '//0'
    8              0.000014   if rev ==# '.git'
                                let f = len(tree) ? tree . '/.git' : dir
                              elseif rev =~# '^\.git/'
    8              0.000059     let f = substitute(rev, '^\.git', '', '')
    8   0.000334   0.000051     let cdir = fugitive#CommonDir(dir)
    8              0.000050     if f =~# '^/\.\./\.\.\%(/\|$\)'
                                  let f = simplify(len(tree) ? tree . f[3:-1] : dir . f)
                                elseif f =~# '^/\.\.\%(/\|$\)'
                                  let f = base . f[3:-1]
                                elseif cdir !=# dir && ( f =~# '^/\%(config\|hooks\|info\|logs/refs\|objects\|refs\|worktrees\)\%(/\|$\)' || f !~# '^/\%(index$\|index\.lock$\|\w*MSG$\|\w*HEAD$\|logs/\w*HEAD$\|logs$\|rebase-\w\+\)\%(/\|$\)' && getftime(FugitiveVimPath(dir . f)) < 0 && getftime(FugitiveVimPath(cdir . f)) >= 0)
                                  let f = simplify(cdir . f)
                                else
    8              0.000036       let f = simplify(dir . f)
    8              0.000008     endif
    8              0.000011   elseif rev ==# ':/'
                                let f = base
                              elseif rev =~# '^\.\%(/\|$\)'
                                let f = base . rev[1:-1]
                              elseif rev =~# '^::\%(/\|\a\+\:\)'
                                let f = rev[2:-1]
                              elseif rev =~# '^::\.\.\=\%(/\|$\)'
                                let f = simplify(getcwd() . '/' . rev[2:-1])
                              elseif rev =~# '^::'
                                let f = base . '/' . rev[2:-1]
                              elseif rev =~# '^:\%([0-3]:\)\=\.\.\=\%(/\|$\)\|^:[0-3]:\%(/\|\a\+:\)'
                                let f = rev =~# '^:\%([0-3]:\)\=\.' ? simplify(getcwd() . '/' . matchstr(rev, '\..*')) : rev[3:-1]
                                if s:cpath(base . '/', (f . '/')[0 : len(base)])
                                  let f = 'fugitive://' . dir . '//' . +matchstr(rev, '^:\zs\d\ze:') . '/' . strpart(f, len(base) + 1)
                                else
                                  let altdir = FugitiveExtractGitDir(f)
                                  if len(altdir) && !s:cpath(dir, altdir)
                                    return fugitive#Find(a:object, altdir)
                                  endif
                                endif
                              elseif rev =~# '^:[0-3]:'
                                let f = 'fugitive://' . dir . '//' . rev[1] . '/' . rev[3:-1]
                              elseif rev ==# ':'
                                if $GIT_INDEX_FILE =~# '/[^/]*index[^/]*\.lock$' && s:cpath(fnamemodify($GIT_INDEX_FILE,':p')[0:strlen(dir)]) ==# s:cpath(dir . '/') && filereadable($GIT_INDEX_FILE)
                                  let f = fnamemodify($GIT_INDEX_FILE, ':p')
                                else
                                  let f = fugitive#Find('.git/index', dir)
                                endif
                              elseif rev =~# '^:(\%(top\|top,literal\|literal,top\|literal\))'
                                let f = matchstr(rev, ')\zs.*')
                                if f=~# '^\.\.\=\%(/\|$\)'
                                  let f = simplify(getcwd() . '/' . f)
                                elseif f !~# '^/\|^\%(\a\a\+:\).*\%(//\|::\)' . (has('win32') ? '\|^\a:/' : '')
                                  let f = base . '/' . f
                                endif
                              elseif rev =~# '^:/\@!'
                                let f = 'fugitive://' . dir . '//0/' . rev[1:-1]
                              else
                                if !exists('f')
                                  let commit = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\|^:.*'), '^@\%($\|[~^]\|@{\)\@=', 'HEAD', '')
                                  let file = substitute(matchstr(rev, '^\%([^:.-]\|\.\.[^/:]\)[^:]*\zs:.*'), '^:', '/', '')
                                  if file =~# '^/\.\.\=\%(/\|$\)\|^//\|^/\a\+:'
                                    let file = file =~# '^/\.' ? simplify(getcwd() . file) : file[1:-1]
                                    if s:cpath(base . '/', (file . '/')[0 : len(base)])
                                      let file = '/' . strpart(file, len(base) + 1)
                                    else
                                      let altdir = FugitiveExtractGitDir(file)
                                      if len(altdir) && !s:cpath(dir, altdir)
                                        return fugitive#Find(a:object, altdir)
                                      endif
                                      return file
                                    endif
                                  endif
                                  let commits = split(commit, '\.\.\.-\@!', 1)
                                  if len(commits) == 2
                                    call map(commits, 'empty(v:val) || v:val ==# "@" ? "HEAD" : v:val')
                                    let commit = matchstr(s:ChompDefault('', [dir, 'merge-base'] + commits + ['--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if commit !~# '^[0-9a-f]\{40,\}$'
                                    let commit = matchstr(s:ChompDefault('', [dir, 'rev-parse', '--verify', commit . (len(file) ? '^{}' : ''), '--']), '\<[0-9a-f]\{40,\}\>')
                                  endif
                                  if len(commit)
                                    let f = 'fugitive://' . dir . '//' . commit . file
                                  else
                                    let f = base . '/' . substitute(rev, '^:/:\=\|^[^:]\+:', '', '')
                                  endif
                                endif
                              endif
    8   0.000098   0.000037   return FugitiveVimPath(f)

FUNCTION  <SNR>64_exec_separator()
Called 40 times
Total time:   0.022759
 Self time:   0.001761

count  total (s)   self (s)
   40              0.000082   if pumvisible()
                                return
                              endif
   40              0.000166   let group = a:from.'_to_'.a:to.a:suffix
   40   0.005801   0.000253   let l:from = airline#themes#get_highlight(a:from.a:suffix)
   40   0.005550   0.000264   let l:to = airline#themes#get_highlight(a:to.a:suffix)
   40              0.000055   if a:inverse
   12              0.000059     let colors = [ l:from[1], l:to[1], l:from[3], l:to[3] ]
   12              0.000009   else
   28              0.000139     let colors = [ l:to[1], l:from[1], l:to[3], l:from[3] ]
   28              0.000021   endif
   40              0.000148   let a:dict[group] = colors
   40   0.010460   0.000296   call airline#highlighter#exec(group, colors)

FUNCTION  airline#statusline()
Called 8 times
Total time:   0.000244
 Self time:   0.000244

count  total (s)   self (s)
    8              0.000107   if has_key(s:contexts, a:winnr)
    8              0.000115     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  airline#util#has_lawrencium()
Called 8 times
Total time:   0.000068
 Self time:   0.000068

count  total (s)   self (s)
    8              0.000027   if !exists("s:has_lawrencium")
                                let s:has_lawrencium  = exists('*lawrencium#statusline')
                              endif
    8              0.000013   return s:has_lawrencium

FUNCTION  airline#highlighter#get_highlight()
Called 232 times
Total time:   0.033596
 Self time:   0.015235

count  total (s)   self (s)
  232              0.003430   let reverse = get(g:, 'airline_gui_mode', '') ==# 'gui' ? synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'gui') : synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'cterm')|| synIDattr(synIDtrans(hlID(a:group)), 'reverse', 'term')
  232              0.001105   if get(g:, 'airline_highlighting_cache', 0) && has_key(s:hl_groups, a:group)
                                let res = s:hl_groups[a:group]
                                return reverse ? [ res[1], res[0], res[3], res[2], res[4] ] : res
                              else
  232   0.009474   0.001364     let fg = s:get_syn(a:group, 'fg')
  232   0.008758   0.001264     let bg = s:get_syn(a:group, 'bg')
  232              0.001249     let bold = synIDattr(synIDtrans(hlID(a:group)), 'bold')
  232              0.000324     if reverse
                                  let res = s:get_array(bg, fg, bold ? ['bold'] : a:000)
                                else
  232   0.004484   0.001727       let res = s:get_array(fg, bg, bold ? ['bold'] : a:000)
  232              0.000208     endif
  232              0.000172   endif
  232              0.001030   let s:hl_groups[a:group] = res
  232              0.000296   return res

FUNCTION  fugitive#CommonDir()
Called 8 times
Total time:   0.000283
 Self time:   0.000283

count  total (s)   self (s)
    8              0.000019   if empty(a:dir)
                                return ''
                              endif
    8              0.000030   if !has_key(s:commondirs, a:dir)
                                if getfsize(a:dir . '/HEAD') < 10
                                  let s:commondirs[a:dir] = ''
                                elseif filereadable(a:dir . '/commondir')
                                  let cdir = get(readfile(a:dir . '/commondir', 1), 0, '')
                                  if cdir =~# '^/\|^\a:/'
                                    let s:commondirs[a:dir] = s:Slash(FugitiveVimPath(cdir))
                                  else
                                    let s:commondirs[a:dir] = simplify(a:dir . '/' . cdir)
                                  endif
                                else
                                  let s:commondirs[a:dir] = a:dir
                                endif
                              endif
    8              0.000023   return s:commondirs[a:dir]

FUNCTION  airline#util#shorten()
Called 24 times
Total time:   0.000830
 Self time:   0.000535

count  total (s)   self (s)
   24   0.000513   0.000218   if airline#util#winwidth() < a:winwidth && len(split(a:text, '\zs')) > a:minwidth
                                if get(a:000, 0, 0)
                                  " shorten from tail
                                  return 'â€¦'.matchstr(a:text, '.\{'.a:minwidth.'}$')
                                else
                                  " shorten from beginning of string
                                  return matchstr(a:text, '^.\{'.a:minwidth.'}').'â€¦'
                                endif
                              else
   24              0.000035     return a:text
                              endif

FUNCTION  airline#highlighter#highlight_modified_inactive()
Called 4 times
Total time:   0.002668
 Self time:   0.000343

count  total (s)   self (s)
    4              0.000041   if getbufvar(a:bufnr, '&modified')
                                let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive_modified.airline_c : []
                              else
    4              0.000101     let colors = exists('g:airline#themes#{g:airline_theme}#palette.inactive.airline_c') ? g:airline#themes#{g:airline_theme}#palette.inactive.airline_c : []
    4              0.000007   endif
                            
    4              0.000020   if !empty(colors)
    4   0.002421   0.000096     call airline#highlighter#exec('airline_c'.(a:bufnr).'_inactive', colors)
    4              0.000007   endif

FUNCTION  airline#extensions#keymap#status()
Called 8 times
Total time:   0.000121
 Self time:   0.000121

count  total (s)   self (s)
    8              0.000058   if (get(g:, 'airline#extensions#keymap#enabled', 1) && has('keymap'))
    8              0.000057     return printf('%s', (!empty(&keymap) ? (g:airline_symbols.keymap . ' '. &keymap) : ''))
                              else
                                return ''
                              endif

FUNCTION  <SNR>64_CheckDefined()
Called 152 times
Total time:   0.004598
 Self time:   0.004598

count  total (s)   self (s)
                              " Checks, whether the definition of the colors is valid and is not empty or NONE
                              " e.g. if the colors would expand to this:
                              " hi airline_c ctermfg=NONE ctermbg=NONE
                              " that means to clear that highlighting group, therefore, fallback to Normal
                              " highlighting group for the cterm values
                            
                              " This only works, if the Normal highlighting group is actually defined, so
                              " return early, if it has been cleared
  152              0.000649   if !exists("g:airline#highlighter#normal_fg_hi")
                                let g:airline#highlighter#normal_fg_hi = synIDattr(synIDtrans(hlID('Normal')), 'fg', 'cterm')
                              endif
  152              0.000702   if empty(g:airline#highlighter#normal_fg_hi) || g:airline#highlighter#normal_fg_hi < 0
                                return a:colors
                              endif
                            
  152              0.000473   for val in a:colors
  152              0.000500     if !empty(val) && val !=# 'NONE'
  152              0.000252       return a:colors
                                endif
                              endfor
                              " this adds the bold attribute to the term argument of the :hi command,
                              " but at least this makes sure, the group will be defined
                              let fg = g:airline#highlighter#normal_fg_hi
                              let bg = synIDattr(synIDtrans(hlID('Normal')), 'bg', 'cterm')
                              if bg < 0
                                " in case there is no background color defined for Normal
                                let bg = a:colors[3]
                              endif
                              return a:colors[0:1] + [fg, bg] + [a:colors[4]]

FUNCTION  airline#util#prepend()
Called 24 times
Total time:   0.000199
 Self time:   0.000199

count  total (s)   self (s)
   24              0.000064   if a:minwidth > 0 && airline#util#winwidth() < a:minwidth
                                return ''
                              endif
   24              0.000085   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>65_update_branch()
Called 8 times
Total time:   0.010073
 Self time:   0.000505

count  total (s)   self (s)
   24              0.000080   for vcs in keys(s:vcs_config)
   16   0.009734   0.000166     call {s:vcs_config[vcs].update_branch}()
   16              0.000075     if b:buffer_vcs_config[vcs].branch != s:vcs_config[vcs].branch
                                  let b:buffer_vcs_config[vcs].branch = s:vcs_config[vcs].branch
                                  unlet! b:airline_head
                                endif
   16              0.000016   endfor

FUNCTION  <SNR>64_get_syn()
Called 464 times
Total time:   0.015604
 Self time:   0.015604

count  total (s)   self (s)
  464              0.001551   if !exists("g:airline_gui_mode")
                                let g:airline_gui_mode = airline#init#gui_mode()
                              endif
  464              0.000789   let color = ''
  464              0.001281   if hlexists(a:group)
  464              0.003005     let color = synIDattr(synIDtrans(hlID(a:group)), a:what, g:airline_gui_mode)
  464              0.000407   endif
  464              0.001279   if empty(color) || color == -1
                                " should always exists
                                let color = synIDattr(synIDtrans(hlID('Normal')), a:what, g:airline_gui_mode)
                                " however, just in case
                                if empty(color) || color == -1
                                  let color = 'NONE'
                                endif
                              endif
  464              0.000645   return color

FUNCTION  airline#extensions#ale#get_warning()
Called 8 times
Total time:   0.001245
 Self time:   0.000065

count  total (s)   self (s)
    8   0.001241   0.000061   return airline#extensions#ale#get('warning')

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    8   0.074074   0.002275  airline#check_mode()
    4   0.068806   0.011786  airline#highlighter#highlight()
  152   0.045612   0.011375  airline#highlighter#exec()
  232   0.033596   0.015235  airline#highlighter#get_highlight()
   40   0.022759   0.001761  <SNR>64_exec_separator()
  464   0.015604             <SNR>64_get_syn()
    8   0.011071   0.000334  airline#extensions#branch#get_head()
   80   0.010834   0.000649  airline#themes#get_highlight()
    8   0.010458   0.000225  airline#extensions#branch#head()
    8   0.010073   0.000505  <SNR>65_update_branch()
    8   0.009000   0.000480  <SNR>65_update_git_branch()
    8   0.008199   0.000194  FugitiveHead()
  152   0.004598             <SNR>64_CheckDefined()
   36   0.004492             <SNR>64_GetHiCmd()
   16   0.004262   0.000586  FugitiveGitDir()
    8   0.004120   0.000486  fugitive#Head()
    8   0.003634   0.002451  fugitive#Find()
    8   0.003615   0.002419  FugitiveExtractGitDir()
    3   0.002807   0.000504  airline#extensions#tabline#get()
  232   0.002757             <SNR>64_get_array()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  464              0.015604  <SNR>64_get_syn()
  232   0.033596   0.015235  airline#highlighter#get_highlight()
    4   0.068806   0.011786  airline#highlighter#highlight()
  152   0.045612   0.011375  airline#highlighter#exec()
  152              0.004598  <SNR>64_CheckDefined()
   36              0.004492  <SNR>64_GetHiCmd()
  232              0.002757  <SNR>64_get_array()
    8   0.003634   0.002451  fugitive#Find()
    8   0.003615   0.002419  FugitiveExtractGitDir()
    8   0.074074   0.002275  airline#check_mode()
    3              0.002061  <SNR>73_map_keys()
   40   0.022759   0.001761  <SNR>64_exec_separator()
  116              0.001737  <SNR>64_hl_group_exists()
   16   0.002244   0.001212  airline#extensions#ale#get()
  108              0.001137  <SNR>64_group_not_done()
    8   0.001376   0.001099  airline#extensions#whitespace#check()
   56              0.000756  airline#util#append()
    3   0.000927   0.000744  airline#extensions#tabline#formatters#unique_tail#format()
   80   0.010834   0.000649  airline#themes#get_highlight()
   16   0.004262   0.000586  FugitiveGitDir()

